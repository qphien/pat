#include <iostream>
#include <vector>



using namespace std;
int best_take_back_to_pbmc = 10000;
int best_take_from_pbmc = 10000;
vector<int> final_path;
int find_shortest_index(const vector<vector<int>> &graph, const vector<bool> collected, int N)
{
	int min_dist = 10000;
	int min_dist_index = -1;
	for (int i = 0; i != N; ++i)
	{
		if (!collected[i] && graph[0][i] < min_dist)
		{
			min_dist = graph[0][i];
			min_dist_index = i;
		}
	}
	return min_dist_index;
}
void find_shortest_path(vector<vector<int>> graph, vector<vector<int>> &path, int N, int Sp)
{
	vector<bool> collected(N);
	//vector<vector<int>> path(N);
	//collected[0] = true;
	int v;
	while (1)
	{
		v = find_shortest_index(graph, collected, N);
		if (v == -1)
			break;
		collected[v] = true;
		for (int w = 0; w != N; ++w)
		{
			if (graph[v][w] != 10000)
			{
				if(!collected[w])
				{
					if (graph[0][w] > graph[0][v] + graph[v][w])
					{
						graph[0][w] = graph[w][0] = graph[0][v] + graph[v][w];
						path[w].resize(1);
						path[w][0] = v;
					}
					else if (graph[0][w] == graph[0][v] + graph[v][w])
					{
						path[w].push_back(v);
					}
				}
			}
		}
	}
	//return path;
}
void find_best_path(vector<vector<int>> path, vector<int> all_bus_station_count, vector<int> &temp_path, int path_index, int half_number, int take_from_pbmc, int take_back_to_pbmc)
{
	//static vector<int> final_path;
	temp_path.push_back(path_index);
	if (all_bus_station_count[path_index] > half_number)
	{
		take_from_pbmc -= all_bus_station_count[path_index] - half_number;
		if (take_from_pbmc < 0)
		{
			take_back_to_pbmc -= take_from_pbmc;
			take_from_pbmc = 0;
		}
	}
	else
	{
		take_from_pbmc += half_number - all_bus_station_count[path_index];
	}
	if (path_index == 0)
	{
		if (take_from_pbmc < best_take_from_pbmc)
		{
			best_take_from_pbmc = take_from_pbmc;
			best_take_back_to_pbmc = take_back_to_pbmc;
			final_path = temp_path;
		}
		else if (take_from_pbmc == best_take_from_pbmc && take_back_to_pbmc < best_take_back_to_pbmc)
		{
			best_take_back_to_pbmc = take_back_to_pbmc;
			final_path = temp_path;
		}
		temp_path.pop_back();
		return;
	}
	for (int i = 0; i < path[path_index].size(); ++i)
	{
		find_best_path(path, all_bus_station_count, temp_path, path[path_index][i], half_number, take_from_pbmc, take_back_to_pbmc);
	}
	temp_path.pop_back();

}
int main()
{
	int Cmax, N, Sp, M;
	int i;
	int temp;
	int Xindex, Yindex;
	cin >> Cmax >> N >> Sp >> M;
	++N;
	int half_number = Cmax >> 1;
	vector<vector<int>> path(N);
	vector<int> all_bike_station_count;
	all_bike_station_count.push_back(half_number);
	for (i = 1; i != N; ++i)
	{
		cin >> temp;
		all_bike_station_count.push_back(temp);
	}
	vector<vector<int>> graph(N);
	for (i = 0; i != N; ++i)
	{
		graph[i] = vector<int>(N, 10000);
	}
	graph[0][0] = 0;
	for (i = 0; i != M; ++i)
	{
		cin >> Xindex >> Yindex >> temp;
		graph[Xindex][Yindex] = graph[Yindex][Xindex] = temp;
	}
	find_shortest_path(graph, path, N, Sp);
	vector<int> temp_path;
	int take_from_pbmc = 0, take_back_to_pbmc = 0;
	find_best_path(path, all_bike_station_count, temp_path, Sp, half_number, take_from_pbmc, take_back_to_pbmc);
	cout << best_take_from_pbmc << ' ';
	for (auto iter = final_path.rbegin(); iter != final_path.rend() - 1; ++iter)
		cout << *iter << "->";
	cout << final_path[0];
	cout << ' ' << best_take_back_to_pbmc;
}
